# Highly divisible triangular number
# Problem 12
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?

from typing import Dict, Generator, Set


def primes(max_prime: int) -> Generator[int, None, None]:
    '''generates the prime numbers using a sieve'''
    max_prime = max(max_prime, 2)
    is_prime = [True] * (max_prime + 1)
    is_prime[0] = False
    is_prime[1] = False
    for number in range(max_prime + 1):
        if is_prime[number]:
            for multiple in range(number ** 2, max_prime + 1, number):
                is_prime[multiple] = False
            yield number


def prime_factorization(n: int) -> Dict[int, int]:
    '''returns the prime factors of n'''
    factors: Dict[int, int] = {}
    max_factor = int(n ** 0.5)
    prime_gen = primes(max_factor)
    next_prime = next(prime_gen)
    while next_prime <= max_factor:
        while n % next_prime == 0:
            if next_prime in factors:
                factors[next_prime] += 1
            else:
                factors[next_prime] = 1
            n = n // next_prime
            max_factor = int(n ** 0.5)
        try:
            next_prime = next(prime_gen)
        except StopIteration:
            break
    if n != 1:
        if n in factors:
            factors[n] += 1
        else:
            factors[n] = 1
    return factors


def combine_factorization(factorization_a: Dict[int, int], factorization_b: Dict[int, int]) -> Dict[int, int]:
    '''combines factorizations'''
    combined_factors: Dict[int, int] = {}
    for factor, count in factorization_a.items():
        combined_factors[factor] = count
    for factor, count in factorization_b.items():
        if factor in combined_factors:
            combined_factors[factor] += count
        else:
            combined_factors[factor] = count
    return combined_factors


def find_divisors(n: int) -> Set[int]:
    '''returns all divisors of n, including 1 and n'''
    divisors = set()
    floored_sqrt = int(n ** 0.5)
    for x in range(1, floored_sqrt + 1):
        if n % x == 0:
            divisors.add(x)
            divisors.add(n // x)
    return divisors


def nth_triangle_number(n: int) -> int:
    '''returns the nth triangle number'''
    return n * (n + 1) // 2


def nth_triangle_divisor_count(n: int) -> int:
    '''returns the numbers of divisors for the nth triangle number'''
    if n % 2 == 0:
        prime_factors = combine_factorization(prime_factorization(n // 2), prime_factorization(n + 1))
    else:
        prime_factors = combine_factorization(prime_factorization(n), prime_factorization((n + 1) // 2))
    divisor_count = 1
    for factor, count in prime_factors.items():
        divisor_count *= count + 1
    return divisor_count


def solve() -> int:
    '''Problem 12 - Highly divisible triangular number'''
    n = 1
    while nth_triangle_divisor_count(n) <= 500:
        n += 1
    return nth_triangle_number(n)


if __name__ == "__main__":
    print(solve())
